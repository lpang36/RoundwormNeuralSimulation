//package wormSimulation;

import java.util.Arrays; //for bug testing only
import java.util.Comparator;
import java.util.Vector;

public class Worm implements Comparable<Worm> {
  //protected int listNum;
  double xPos;
  double yPos;
  //double lastX; //for drawing
  //double lastY;
  double speed;
  double direction;
  int layers = 5;
  private double speedLimit = 0.05;
  private Vector<Double> pastHealth = new Vector<Double>();
  double health = 0; //really, this should be some kind of weighting thing 
  //double prevHealth = 0; //for color
  boolean isDead = false;
  int age = 0;
  //int ageLimit = 50; //useless rn
  private int inputNum; //varies w num of "chemicals"
  private int outputNum; //arbitrarily, 0, 1 horizontal, 2, 3 vertical
  private int num = 200;
  private Neuron[] inputArray;
  private Neuron[] outputArray;
  private Vector<Vector<Neuron>> array = new Vector<Vector<Neuron>>(layers); //maybe combine all of these?
  //private Synapse[] synapses;
  int[] genome = new int [layers]; //one for each layer rn
  double weightP;
  double delayP;
  double thresh;
  private int geneMutationFactor = 5; //eventually this should be an array type thing
  private double weightMutationFactor = 0.05;
  private double delayMutationFactor = 0.01;
  private double threshMutationFactor = 0.05;
  private double minThresh = 0.01;
  //private boolean[][] synapseMap; //maybe too memory intensive (also not efficient as half is unused)
  private int synapseNum = 0;
  //private double geneMutationFactor = 0.1;
  //private double synapseMutationFactor = 0.1;
  //private double riskFactor;
  //private double riskMutationFactor = 0.1;
  //private double[][][] map;
  Colony C;
  private double speedScaling = 1;
  private double directionScaling = 0.1;
  public Worm (Colony X) {
    //pastHealth = new Vector<Double>();
    xPos = 0;
    yPos = 0; //later overridden
    C = X;
    inputNum = C.inputNum;
    outputNum = C.outputNum;
    //map = C.map;
    //genome = new double [inputNum+outputNum+num];
    //riskFactor = 1;
    for (int i = 0; i<layers; i++) {
      genome[i] = (int)(Math.random()*num/(layers/2.0))+1; //lowkey bs
      //genome[i] = 3+i;
    }
    weightP = Math.random();
    delayP = Math.random();
    thresh = 1;
    initialize();
    //int targetSynapseNum = 3000;
    //synapseMap = new boolean[inputNum+outputNum+num][inputNum+outputNum+num];
    //int possibleSynapseNum = (inputNum+outputNum+num)*(inputNum+outputNum+num-1)/2;
    //double prob = targetSynapseNum/(possibleSynapseNum+0.0);
    /*
    for (int i = 0; i<inputNum; i++) {
      for (int j = 0; j<num; j++) {
        if (Math.random()<prob) {
          synapseMap[i][j+inputNum] = true;
          Synapse S = new Synapse (inputArray[i],array[j]);
          //inputArray[i].addOutputSynapse(S); //put this shit inside the add method
          //array[j].addInputSynapse(S);
          synapseNum++;
        }
      }
      //inputArray[i].initialize();
    }
    for (int i = 0; i<num; i++) {
      for (int j = i+1; j<num+outputNum; j++) {
        if (Math.random()<prob) {
          synapseMap[i+inputNum][j+inputNum] = true;
          if (j<num) {
            Synapse S = new Synapse (array[i],array[j]);
            //array[i].addOutputSynapse(S);
            //array[j].addInputSynapse(S);
          }
          else {
            Synapse S = new Synapse (array[i],outputArray[j-num]);
            //array[i].addOutputSynapse(S);
            //outputArray[j-num].addInputSynapse(S);
          }
          synapseNum++;
        }
      }
      if (!array[i].inConn) {
        Synapse S = new Synapse (inputArray[(int)Math.random()*inputNum],array[i]);
      }
      /*
      if (!array[i].outConn) {
        Synapse S = new Synapse (array[i],array[(int)Math.random()*outputNum],riskFactor);
      }
      //array[i].initialize();
    }
    */
    //System.out.println(synapseNum);
    /*
    for (int i = 0; i<num; i++) {
      if (!array[i].inConn)
      System.out.println ("in");
      if (!array[i].outConn)
      System.out.println ("out");
    }
    */
    //System.out.println(Arrays.deepToString(synapseMap));
    //System.out.println(Runtime.getRuntime().freeMemory());
  } //SOME NEURONS WILL BE USELESS! e.g. near end w/ no output conns
  public Worm (Worm A, Worm B) {
    C = A.C;
    inputNum = C.inputNum;
    outputNum = C.outputNum;
    genome = new int [layers];
    for (int i = 0; i<layers; i++) {
      int x;
      if (Math.random()>0.5) 
        x = A.genome[i];
      else
        x = B.genome[i];
      genome[i] = (int)Math.max(1,Math.round(x+Math.random()*2*geneMutationFactor-geneMutationFactor));
      //System.out.print(genome[i]+" ");
    }
    if (Math.random()>0.5)
      weightP = A.weightP;
    else
      weightP = B.weightP;
    weightP+=Math.random()*2*weightMutationFactor-weightMutationFactor;
    if (Math.random()>0.5)
      delayP = A.delayP;
    else
      delayP = B.delayP;
    delayP+=Math.random()*2*delayMutationFactor-delayMutationFactor;
    if (Math.random()>0.5) 
      thresh = A.thresh;
    else
      thresh = B.thresh;
    thresh+=Math.random()*2*threshMutationFactor-threshMutationFactor;
    if (thresh<minThresh)
      thresh = minThresh;
        //System.out.println(weightP+" "+delayP+" "+thresh);
    initialize();
    //xPos = Math.random();
    //yPos = Math.random();
    xPos = (A.xPos+B.xPos)/2;
    yPos = (A.yPos+B.yPos)/2;
    //speed = (A.speed+B.speed)/2;
    //direction = (A.direction+B.direction)/2;
    //riskFactor = (A.riskFactor+B.riskFactor+Math.random()*2*riskMutationFactor-riskMutationFactor)/2;
    /*
    inputArray = new Neuron[inputNum];
    outputArray = new Neuron[outputNum];
    array = new Neuron[num];
    /*
    genome = new double[inputNum+outputNum+num];
    for (int i = 0; i<inputNum+outputNum+num; i++) {
      genome[i] = (A.genome[i]+B.genome[i]+Math.random()*2*geneMutationFactor-geneMutationFactor)/2;
    }
    
    for (int i = 0; i<inputNum; i++) {
      Neuron N = new Neuron ();
      N.inConn = true;
      inputArray[i] = N;
    }
    for (int i = 0; i<outputNum; i++) {
      Neuron N = new Neuron ();
      N.outConn = true;
      outputArray[i] = N;
    }
    for (int i = 0; i<num; i++) {
      Neuron N = new Neuron ();
      array[i] = N;
    }
    synapseMap = new boolean[inputNum+outputNum+num][inputNum+outputNum+num];
    for (int i = 0; i<inputNum+num; i++) {
      for (int j = i+1; j<inputNum+outputNum+num; j++) {
        if (A.synapseMap[i][j]==B.synapseMap[i][j]) {
          synapseMap[i][j] = A.synapseMap[i][j];
        }
        else {
          if (Math.random()>0.5) {
            synapseMap[i][j] = true;
          }
        }
        if (Math.random()<synapseMutationFactor) {
          synapseMap[i][j] = !synapseMap[i][j];
        }
        if (synapseMap[i][j]) { //ugly af
          if (i<inputNum&&j>=inputNum&&j<inputNum+num) {
            Synapse S = new Synapse (inputArray[i],array[j-inputNum]);
            //inputArray[i].addOutputSynapse(S);
            //array[j-inputNum].addInputSynapse(S);
            synapseNum++;
          }
          else if (i>=inputNum) {
            if (j<inputNum+num) {
              Synapse S = new Synapse (array[i-inputNum],array[j-inputNum]);
              //array[i-inputNum].addOutputSynapse(S);
              //array[j-inputNum].addInputSynapse(S);
              synapseNum++;
            }
            else {
              Synapse S = new Synapse (array[i-inputNum],outputArray[j-inputNum-num]);
              //array[i-inputNum].addOutputSynapse(S);
              //outputArray[j-inputNum-num].addInputSynapse(S);
              synapseNum++;
            }
          }
        }
      }
      /*
      if (i<inputNum) {
        inputArray[i].initialize();
      }
      else {
        array[i-inputNum].initialize();
      }
      
      if (i>=inputNum&&i<inputNum+num) {
        if (!array[i-inputNum].inConn) {
          Synapse S = new Synapse (inputArray[(int)Math.random()*inputNum],array[i-inputNum]);
          synapseNum++;
        }
        /*
        if (!array[i].outConn) {
          Synapse S = new Synapse (array[i],array[(int)Math.random()*outputNum],riskFactor);
        }
        
      }
    }
    for (int i = 0; i<inputNum; i++) {
      inputArray[i].initialize();
    }
    for (int i = 0; i<outputNum; i++) {
      outputArray[i].initialize();
    }
    for (int i = 0; i<num; i++) {
      array[i].initialize();
    }
    //System.out.println(synapseNum);
    //System.out.println(Runtime.getRuntime().freeMemory());
    */
  }
  public void initialize () {
    speed = Math.random()*speedLimit;
    direction = Math.random()*6.28;
    inputArray = new Neuron[inputNum];
    outputArray = new Neuron[outputNum];
    for (int i = 0; i<inputNum; i++) {
      Neuron N = new Neuron (thresh);
      //N.inConn = true;
      inputArray[i] = N;
    }
    for (int i = 0; i<outputNum; i++) {
      Neuron N = new Neuron (thresh);
      //N.outConn = true;
      outputArray[i] = N;
    }
    for (int i = 0; i<layers; i++) {
      Vector<Neuron> newLayer = new Vector<Neuron>();
      for (int j = 0; j<genome[i]; j++) {
            Neuron N = new Neuron (thresh);
            newLayer.add(N);
      }
      array.add(newLayer);
    }
    for (int i = 0; i<inputNum; i++) {
      for (int j = 0; j<array.get(0).size(); j++) {
        Synapse S = new Synapse(inputArray[i],array.get(0).get(j),weightP,delayP);
        synapseNum++;
      }
    }
    for (int i = 0; i<layers-1; i++) {
      for (int j = 0; j<array.get(i).size(); j++) {
        for (int k = 0; k<array.get(i+1).size(); k++) {
          Synapse S = new Synapse(array.get(i).get(j),array.get(i+1).get(k),weightP,delayP);
          synapseNum++;
        }
      }
    }
    /*
    for (int i = 0; i<layers; i++) {
      for (int j = 0; j<array.get(i).size(); j++) {
        for (int k = j+1; k<array.get(i).size(); k++) {
          Synapse S = new Synapse(array.get(i).get(j),array.get(i).get(k),weightP,delayP);
          synapseNum++;
        }
      }
    }
    */
    for (int i = 0; i<outputNum; i++) {
      for (int j = 0; j<array.get(layers-1).size(); j++) {
        Synapse S = new Synapse(array.get(layers-1).get(j),outputArray[i],weightP,delayP);
        synapseNum++;
      }
    }
    initializeNeurons();
  }
  public void initializeNeurons() {
    for (int i = 0; i<inputNum; i++) {
      inputArray[i].initialize();
    }
    for (int i = 0; i<outputNum; i++) {
      outputArray[i].initialize();
    }
    for (int i = 0; i<layers; i++) {
      for (int j = 0; j<array.get(i).size(); j++) {
        array.get(i).get(j).initialize();
      }
    }
  }
  public void move() {
    //lastX = xPos;
    //lastY = yPos;
    for (int i = 0; i<inputNum; i++) {
      //System.out.println("start read " + i);
      inputArray[i].read(C.map[posToMapX()][posToMapY()][i]);
      //System.out.println("read in " + i);
    }
    //System.out.println("all fired");
    double[] times = new double[outputNum];
    for (int i = 0; i<outputNum; i++) {
      if (outputArray[i].time!=0) {
        times[i] = 1/outputArray[i].time;
      }
      else {
        times[i] = 0;
      }
      //System.out.println(outputArray[i].time);
      //System.out.println (outputArray[i].receivedInputs());
    }
          //System.out.println(times[0]-times[1]);
                //System.out.println(times[2]-times[3]);
    if ((times[0]-times[1])/speedScaling>0)
      speed = Math.min(speed+(times[0]-times[1])/speedScaling,speedLimit);
    else
      speed = Math.max(speed+(times[0]-times[1])/speedScaling,-speedLimit);
    //System.out.println(speed);
    direction = direction+(times[2]-times[3])/directionScaling;
    updatePositions();
      /*
    if (times[0]<times[1]) {
      xPos = Math.min(map.length-1,xPos+1); //dimensions might be flipped
    }
    else {
      xPos = Math.max(0,xPos-1);
    }
    if (times[2]<times[3]) {
      yPos = Math.min(map[0].length-1,yPos+1);
    }
    else {
      yPos = Math.max(0,yPos-1);
    }
    */
    initializeNeurons();
    /*
    //System.out.println(sends[0]+" "+sends[1]);
    if (sends[0]>0) {
      xPos = Math.min(map.length,xPos+(int)Math.min(Math.round(sends[0]),1)); //dimensions might be flipped
    }
    else {
      xPos = Math.max(0,xPos+(int)Math.max(Math.round(sends[0]),-1));
    }
    if (sends[1]>0) {
      yPos = Math.min(map[0].length,yPos+(int)Math.min(Math.round(sends[1]),1));
    }
    else {
      yPos = Math.max(0,yPos+(int)Math.max(Math.round(sends[1]),-1));
    }
    */
    //System.out.println(xPos+" "+yPos);
    this.updateHealth();
    age++;
    /*
    if (age>ageLimit) {
      this.die();
    }
    */
  }
  public void updatePositions() {
    xPos = xPos+speed*Math.cos(direction);
    yPos = yPos+speed*Math.sin(direction);
  }
  public int posToMapX () {
    if (xPos<0) {
      xPos = 0;
    }
    else if (xPos>=1) {
      xPos = 1;
      return C.map.length-1;
    }
    return (int)(xPos*C.map.length);
  }
  public int posToMapY () {
    if (yPos<0) {
      yPos = 0;
    }
    else if (yPos>=1) {
      yPos = 1;
      return C.map[0].length-1;
    }
    return (int)(yPos*C.map[0].length);
  }
  public void updateHealth() {
    //prevHealth = health;
    //System.out.println(posToMapX());
    //System.out.println(map[posToMapX()][posToMapY()][0]);
    double current = C.map[posToMapX()][posToMapY()][0]-C.map[posToMapX()][posToMapY()][1]; //0 is good 1 is bad
    //dynamic map
    if (C.dynamic) {
      for (int i = 0; i<C.map[0][0].length; i++) {
        //C.map[posToMapX()][posToMapY()][i]-=0.1;
        if (C.map[posToMapX()][posToMapY()][i]<0)
          C.map[posToMapX()][posToMapY()][i]=0;
      }
    }
    pastHealth.add(current);
    health = 0;
    for (int i = 0; i<pastHealth.size(); i++) {
      health = health+pastHealth.get(i)*Math.pow(0.5,pastHealth.size()-i)/(Math.pow(2.0,pastHealth.size())-1);
    }
    //System.out.println(health);
  }
  public int healthColor() {
    int shade = 128+(int)((health)*128);
    if (shade<0)
      shade=0;
    else if (shade>255)
      shade=255;
    return shade;
  }
  public int ageColor() {
    if (age<=1) 
      return 255;
    return 0;
    //return (int)(255*age/(ageLimit+0.0));
  }
  public int compareTo(Worm W) {
    double result = this.health-W.health;
    if (result>0) {
      return 1;
    }
    else if (result==0) {
      return 0;
    }
    return -1;
  }
  public Comparator<Worm> WormCompare () {
    return new Comparator<Worm> () {
      public int compare(Worm X, Worm Y) {
        return X.compareTo(Y);
      }
    };
  }
  //basically a destructor...make it one if memory becomes an issue
  public void die() {
    health = Double.NEGATIVE_INFINITY;
    isDead = true;
  }
}